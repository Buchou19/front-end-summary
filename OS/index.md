#### 1. 进程 线程 同步 异步 并行 串行 并发

**进程**：进程是操作系统分配给应用程序独享的一块资源，一般一个应用程序至少拥有一个进程，进程的资源（内存、CPU、I/O等）是独立的，进程之间不共享资源；

**线程**：线程可以看作是进程执行的最小单位，是“轻量级”的进程，线程没有独立的资源，需要进程提供，多个线程可以共享进程资源；

**同步**：代码按照书写顺序，依次执行，如A-B-C-D；

**异步**：代码不按照书写顺序依次执行，如A-C-D-B；

**并行**：在同一时间**点**，多个处理器处理任务（可以是同一个任务，也可以是不同的任务）；

**串行**：在任一时间**点**，都只有一个处理器在处理任务；

理解——并行不一定异步（多个CPU同时依次处理A-B-C-D），异步也不一定需要并行（一个CPU处理A-C-D-B）

**并发**：**并行**显然只能在多核CPU上出现，而在单核CPU时代，**并发是为了模拟并行**的，就是把CPU的运行时间切分成很小的时间片，然后每一个时间片，依次处理A-B-C-D，由于很快，就感觉A、B、C、D在同时被执行，在每个时间**点**上，CPU还是在处理一个任务，本质还是串行，但是一个时间**段**内，可以看作是A、B、C、D被同时执行。

#### 2. 进程间通信方式

每个进程的用户地址空间都是独立的，一般而言是不能相互访问的（为什么？因为多进程是要频繁切换执行的，若多个进程频繁切换操作同一个地址空间内容，总会出现错误），但是内核空间是每个进程都共享的，所以进程之间通信必须通过内核。

————————————————————————————————————————————————————————————

|								进程1（用户空间）								进程2（用户空间）								进程3（用户空间）			  				|

————————————————————————————————————————————————————————————

|																										内核空间																										  |

————————————————————————————————————————————————————————————

##### ——管道——

**所谓的管道，就是内核里面的一串缓存**

从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是*无格式的流且大小受限*（FIFO先进先出）。

管道通信时**单向的**，若想双向通信，需要创建**两个管道**。

但是有一点，假如进程A把数据存入管道，只能等待数据被进程B读取后才能返回！所以如下：

- 优点：**简单**，能保证数据真的被其他数据拿走
- 缺点：**效率低**，且只能单向通信，不适合频繁交换数据

##### ——消息队列——

管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。

对于这个问题，**消息队列**的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据**放在对应的消息队列后就可以正常返回**了，B 进程**需要的时候再去读取数据**就可以了。同理，B 进程要给 A 进程发送消息也是如此。

**消息队列是保存在内核中的消息链表**，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。

消息队列的读取和写入的过程，都会有发生**用户态与内核态之间的消息拷贝过程**。

- 优点：效率比管道高，可以**频繁沟通**
- 缺点：通信不及时，不适合传送**大数据**（因为拷贝占用时间长）

##### ——共享内存——

现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己**独立的虚拟内存空间**，**不同进程的虚拟内存映射到不同的物理内存中**。所以，*即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址*，对于数据的增删查改互不影响。

**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。

用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。

- 优点：无需拷贝，可频繁交换大数据，速度快
- 缺点：线程安全问题、多进程竞争问题（给谁用？怎么用？）

##### ——信号量——

为了**防止多进程竞争共享资源**，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，**信号量**就实现了这一保护机制。

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据**。

[理解信号量](https://www.bilibili.com/video/BV1d4411v7u7?p=16) 这个视频辅助理解信号量 (-___-)

理解：信号量为负值表明有多少进程在等待，唤醒一个+1，为正值表明还剩余可使用的资源，当然还有加锁的信号量，进去之后锁值改变。

##### ——Socket——

（了解）

前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想**跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。**

实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。

我们来看看创建 socket 的系统调用：

```text
int socket(int domain, int type, int protocal)
```

监听的 socket 和真正用来传送数据的 socket，是「**两个**」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。

成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。

##### ——总结——

由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。

Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。

**匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「`|`」竖线就是匿名管道，通信的数据是**无格式的流并且大小受限**，通信的方式是**单向**的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信**，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。

**命名管道**突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核**中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。

**消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。**

**共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问**，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，享有**最快**的进程间通信方式之名。但是便捷高效的共享内存通信，**带来新的问题，多进程竞争同个共享资源会造成数据的错乱。**

那么，就需要**信号量**来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 **P 操作和 V 操作**。

与信号量名字很相似的叫**信号**，它俩名字虽然相似，但功能一点儿都不一样。信号是进程间通信机制中**唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，**进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SEGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。

前面说到的通信机制，都是工作于同一台主机，如果**要与不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

以上，就是进程间通信的主要机制了。

